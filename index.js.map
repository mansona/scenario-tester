{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Project } from 'fixturify-project';\nimport { setGracefulCleanup } from 'tmp';\nimport { spawn } from 'child_process';\n\nsetGracefulCleanup();\n\ntype ProjectMutator = (project: Project) => void | Promise<void>;\n\nexport { Project };\n\ntype State =\n  | {\n      type: 'root';\n      root: () => Project | Promise<Project>;\n    }\n  | {\n      type: 'derived';\n      parent: Scenarios;\n      variants: Record<string, ProjectMutator[]>;\n    };\n\nexport class Scenarios {\n  static fromDir(appPath: string, as: 'app' | 'lib' = 'app'): Scenarios {\n    return new this({\n      type: 'root',\n      root: () =>\n        Project.fromDir(appPath, as === 'app' ? { linkDevDeps: true } : { linkDeps: true }),\n    });\n  }\n\n  static fromProject(fn: () => Promise<Project> | Project): Scenarios {\n    return new this({\n      type: 'root',\n      root: fn,\n    });\n  }\n\n  expand(variants: Record<string, ProjectMutator>): Scenarios {\n    return new Scenarios({\n      type: 'derived',\n      parent: this,\n      variants: Object.fromEntries(\n        Object.entries(variants).map(([variantName, mutator]) => [variantName, [mutator]])\n      ),\n    });\n  }\n\n  skip(variantName: string): Scenarios {\n    if (this.state.type === 'root') {\n      throw new Error(`no variant named ${variantName} available to skip on root scenario`);\n    }\n    if (!this.state.variants[variantName]) {\n      throw new Error(\n        `no variant named ${variantName} available to skip. Found variants: ${Object.keys(\n          this.state.variants\n        ).join(', ')}`\n      );\n    }\n    let variants = Object.assign({}, this.state.variants);\n    delete variants[variantName];\n    return new Scenarios({\n      type: 'derived',\n      parent: this.state.parent,\n      variants,\n    });\n  }\n\n  only(variantName: string): Scenarios {\n    if (this.state.type === 'root') {\n      throw new Error(`no variant named ${variantName} available to skip on root scenario`);\n    }\n    if (!this.state.variants[variantName]) {\n      throw new Error(\n        `no variant named ${variantName} available to select via \"only\". Found variants: ${Object.keys(\n          this.state.variants\n        ).join(', ')}`\n      );\n    }\n    let variants = { [variantName]: this.state.variants[variantName] };\n    return new Scenarios({\n      type: 'derived',\n      parent: this.state.parent,\n      variants,\n    });\n  }\n\n  map(name: string, fn: ProjectMutator): Scenarios {\n    if (this.state.type === 'root') {\n      return new Scenarios({\n        type: 'derived',\n        parent: this,\n        variants: {\n          [name]: [fn],\n        },\n      });\n    } else {\n      return new Scenarios({\n        type: 'derived',\n        parent: this.state.parent,\n        variants: Object.fromEntries(\n          Object.entries(this.state.variants).map(([variantName, mutators]) => [\n            `${variantName}-${name}`,\n            [...mutators, fn],\n          ])\n        ),\n      });\n    }\n  }\n\n  private iterate(\n    fn: (args: {\n      name: string | undefined;\n      root: () => Project | Promise<Project>;\n      mutators: ProjectMutator[];\n    }) => void\n  ): void {\n    if (this.state.type === 'root') {\n      fn({ name: undefined, root: this.state.root, mutators: [] });\n    } else {\n      let state = this.state;\n      this.state.parent.iterate((parent) => {\n        for (let [variantName, mutators] of Object.entries(state.variants)) {\n          let combinedName = parent.name ? `${parent.name}-${variantName}` : variantName;\n          fn({\n            name: combinedName,\n            root: parent.root,\n            mutators: [...parent.mutators, ...mutators],\n          });\n        }\n      });\n    }\n  }\n\n  forEachScenario(fn: (appDefinition: Scenario) => void): void {\n    this.iterate(({ name, root, mutators }) => {\n      fn(new Scenario(name ?? '<root>', root, mutators));\n    });\n  }\n\n  private constructor(private state: State) {}\n}\n\nexport const seenScenarios: Scenario[] = [];\n\nexport class Scenario {\n  constructor(\n    public name: string,\n    private getBaseScenario: () => Project | Promise<Project>,\n    private mutators: ProjectMutator[]\n  ) {\n    seenScenarios.push(this);\n  }\n\n  async prepare(outdir?: string): Promise<PreparedApp> {\n    let project = await this.getBaseScenario();\n    for (let fn of this.mutators) {\n      await fn(project);\n    }\n\n    if (outdir) {\n      project.baseDir = outdir;\n    }\n    await project.write();\n    return new PreparedApp(project.baseDir);\n  }\n}\n\nexport class PreparedApp {\n  constructor(public dir: string) {}\n  async execute(\n    shellCommand: string,\n    opts?: { env?: Record<string, string> }\n  ): Promise<{\n    exitCode: number;\n    stderr: string;\n    stdout: string;\n    output: string;\n  }> {\n    let env: Record<string, string | undefined> | undefined;\n    if (opts?.env) {\n      env = { ...process.env, ...opts.env };\n    }\n    let child = spawn(shellCommand, {\n      stdio: ['inherit', 'pipe', 'pipe'],\n      cwd: this.dir,\n      shell: true,\n      env,\n    });\n    let stderrBuffer: string[] = [];\n    let stdoutBuffer: string[] = [];\n    let combinedBuffer: string[] = [];\n    child.stderr.on('data', (data) => {\n      stderrBuffer.push(data);\n      combinedBuffer.push(data);\n    });\n    child.stdout.on('data', (data) => {\n      stdoutBuffer.push(data);\n      combinedBuffer.push(data);\n    });\n    return new Promise((resolve) => {\n      child.on('close', (exitCode: number) => {\n        resolve({\n          exitCode,\n          get stdout() {\n            return stdoutBuffer.join('');\n          },\n          get stderr() {\n            return stderrBuffer.join('');\n          },\n          get output() {\n            return combinedBuffer.join('');\n          },\n        });\n      });\n    });\n  }\n}\n"]}